**O que é o QA**

<img width="561" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/3c99c4f8-3570-49a8-b184-eeb5aea63e6a">

O que é um Quality Assurance?

<img width="583" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/13114c53-6218-4290-801a-f608e398eb26">


<img width="579" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/4fef0233-824a-49f0-80a0-6e8fd14b3aba">

Quem corrige bug é Desenvolvedor;

**SDLC + DEVOPS**

Software Development Life Cycle (SDLC)

![image](https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/a7e45d15-33ba-4b5c-9413-0b554a1b9211)


<img width="563" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/58cb7aed-9f9b-4ac1-ac86-0839a2cc9cd9">

<img width="538" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/5bf82941-2765-46ff-bde4-26cb65ba14b9">

 1. Request é por onde a demanda vem pelo o time de atendimento ao produto, pode ser um bug, uma análise de concorrente, um erro que foi encontrado em produção, uma necessidade técnica de adequação da própria ferramenta, é de onde nasce a ideia, o momento inicial da comunicação. Realizado pelo o time de produto ou de atendimento
     
 <img width="608" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/e90af8b9-22e0-4c9d-bddf-7e684e0bc9c1">

2. Analisys : é feita uma análise pelo o time de produto e levantamento de requisitos(PO, PM...). Trabalham nessa etapa para descrever a necessidade, levantar requisitos, entender como a aplicação precisa se comportar, entender como será implementado pelo o ponto de vista de requisitos e de necessidade da aplicação;
   
<img width="597" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/43caa60b-f7f0-4041-83b7-eb317b88fcae">

3. Depois que o pessoal de produto fez esse levantamento de requisitos tem a etapa de Design, é a parte em que o time de UX e UI vão analisar a necessidade que o time de produto trouxe e vai trabalhar em cima dela. De repente aplicar alguns testes de usabilidade junto com os usuários para entender a necessidade e conseguir chegar na conclusão de uma solução. Com base com que o produto passou eles vão fazer a Experiencia do usuário, entender a melhor interface;

<img width="434" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/d291cb48-d806-450c-bd42-0d2118ea1ca8">

4. Analisys and Code: é o momento em que o desenvolvedor vai verificar o que foi passado para ele junto com Design e analise de produto, ali ele vai fazer o levantamento técnico, para entender como aquilo vai se comportar, qual a arquitetura a máquina que ele vai precisar para fazer aquela implementação, vai entender se vai precisar de algum time externo, de uma máquina diferente, alguma instalação , análise de risco, análise de impacto e depois codar para desenvolver a feature, bug e outros

<img width="479" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/bd311712-d8b1-4169-b36f-748aa0401019">

5. Build: nada mais que quando o código fonte é compilado e construido em um pacote executável. Imagina na etapa 4 o desenvolvedor codou, mas ele biuldou, ou seja compilando aquele novo cíodigo, ele deixa o antigo código sem a implementação e ele inclui esse novo código com a nova implementação que ele adicionou.
   
<img width="490" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/c5138a9a-c1ae-486d-836e-7da757c68353">

Após o Build é a parte de operações do DEVOPS, tem mais a ver com as ferramentas que a equipe está usando no dia a dia, para disponibilizar esses códigos, essa nova funcionalidade, seja em produção, seja em ambiente de homologação, ou até pacotes, . apk um executável;

6. Test: é a etapa em que o software é testado para garantir o correto funcionamento, os testes são adicionados aqui como uma etapa de validação daquela nova funcionalidade, seja uma nova feature ou um bug;

<img width="542" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/5b3cb522-02d3-495b-85e9-e3b888eac4d3">

7. Release: momento de preparo para que o software seja instalação em ambiente de produção, momento onde vc identifica as máquinas se precisa fazer algum ajuste, escalar alguma máquina que ela performe melhor e que atenda todos os usuários, verificar a parte de infraestrutura,  momento de preparo daquele pacote , que é para liberar em ambiente produtivo.

<img width="513" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/ffc7d1cc-1d55-4ae3-a7c2-8919a1a12a63">

8. deploy:é quando o software é implantado e se torna acessivel aos usuários finais.
   
<img width="520" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/7c6fae1b-4df9-4226-b703-b6cf4f83ba30">

9. Operate : operação é quando ele é executado em ambiente produtivo e a equipe de operações monitora o desempenho, a disponibilidade e a segurança da aplicação, aqui temos o time de operações atuando, vindo do devops, são pessoas específicas que cuidam daquele software em produção de uma maneira que n]ao fique indisponível, não tenha brechas de segurana.

<img width="556" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/d686ce1c-1d61-4162-bd47-f5d69d986a2e">

10. Monitor:Monitoramento, é o time como um todo que acompanha/monitora esse software em produção, não é só o time de operação. é o time de produto, de desenvolvimento que começa a monitorar esse software , pegando log, métricas e dados relevantes. Momento extremamente importante, para verificar se está saudável a aplicação, com mais qualidade.

    <img width="563" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/09897d24-bc24-493d-81ad-bc389b375807">


**Papéis e responsabilidade no SDLC ágil**

<img width="588" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/a548c201-ec93-4dbb-9ccf-5f11ade281f7">

Definir a visão, a estratégia do produto, entender quais são as necessidades do cliente, do mercado, definir as metas, os objetivos, tudo isso tudo que está relacionado ao produto que esteja documentado. Todo time fique ciente de quais são os objetivos e as metas e que eles sejam explicados de uma forma bastante clara.

Backlog:  é uma lista priorizada de todas as funcionalidades, melhorias, correções e tudo o mais que devem ser implementadas no produto.

A forma como o time de desenvolvimento trabalha é sempre baseada no que o PO prioriza. É responsabilidade dele dizer o que a gente tem que fazer e o momento certo, é responsabilidade dele priorizar e despriorizar.

Ele monitora o progresso, ele faz os ajustes das prioridades, ele mantém os clientes também atualizado do momento atual, do desenvolvimento. É ele quem toma as decisões para que a gente possa maximizar o valor, baseado inclusive nas prioridades que ele define.

Também faz parte do papel dele documentar, fazer algumas documentações de um modo geral. Em algumas empresas isso é responsabilidade do time.


<img width="571" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/71bed1bf-9882-4396-8093-4fc43116f8aa">

O time de desenvolvimento, ele tem que analisar os requisitos, tem que compreender aqueles requisitos de projeto ou do cliente, para ele conseguir identificar quais são as funcionalidades características que o software deve ter. Entender as restrições, A ideia é que a gente saiba o que a gente está construindo e não simplesmente só saia codando, uma segunda responsabilidade é o designer e Arquitetura do Software, com base naqueles requisitos identificados, o time de desenvolvimento, ele vai ser o responsável por projetar a arquitetura desse software.

Toda essa parte de arquitetura, ela é definida pelo time de arquiteto e de desenvolvedores, e isso inclui também a estrutura geral do sistema, e isso inclui a arquitetura geral do sistena, os componentes principais, como as interfaces vão funcionar.

Codificar é uma das principais, responsabilidades do time de desenvolvimento, é escrever o código e codar e colocar a mão na massa, fazer com que ele funcione corretamente, que atenda os requisitos estabelecidos anteriormente ali na nossa análise.E isso também inclui codar ali a parte de testes e testes unitários. Isso é responsabilidade total do time de desenvolvimento.
Realmente é a parte de fazer algo sair de um requisito e se transformar num sistema. Testar faz parte também do papel do arquiteto e do desenvolvedor. Testar e garantir o que ele está construindo.
Faz parte de um grande profissional, de um grande desenvolvedor, de um grande arquiteto. É saber testar também, depurar, corrigir bugs.

Durante o processo de desenvolvimento, podem surgir, falhas, vão surgir, bugs, erros, naquele software, e o time de desenvolvimento deve ser capaz de conseguir identificar, corrigir esses problemas, e não importa de onde ele venha, pode vir de um outro time, pode vir de um outro desenvolvedor, pode vir de cliente. A ideia é que a gente vá construindo e garantindo que esse software ele fique com o mínimo de falhas,

O PO diz o quê, e os devs vão analisando e vendo como vai construindo. 


<img width="553" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/b4d9dad9-b211-47c0-9e76-d510a0e1a863">

A criar, executar e manter testes.Criar e manter scripts, tudo envolvendo teste, principalmente na camada end2end  com o olhar de usuário, e também apoiar os desenvolvedores, auxiliando testes de unidade.
Identificar e relatar defeitos, o QA tem uma visão apurada para achar e relatar defeitos.


<img width="587" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/fae9bf05-e746-45ec-8060-1f2edc3afa1a">


**Modelo Cascata X ÁGIL**

Ele é o modelo que durante muitos anos foi o que dominou a forma como se desenvolvia software.

Ele é dividido em cinco etapas.

<img width="490" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/25ec09a6-a06e-4a84-91d0-31bf7f6112cb">

A primeira delas é a parte de requerimento, que é onde a gente faz o levantamento dos requisitos. E através de entrevistas, através de reuniões com o cliente, a gente levanta os requisitos, tenta entende quais são as expectativas do cliente, define quais são as funcionalidades que aquele sistema tem que ter para que a gente possa implementar e resolver solucionar o que o cliente precisa.

A fase de requerimento é extremamente importante, porque é onde vai ter tudo o que o sistema vai precisar para que solucione o problema do cliente e todas as funcionalidades que precisar ter.

Saindo dessa parte e considerando que temos todos os documentos com os requisitos, entramos numa segunda fase, que é a parte de design, que em algumas literaturas se chama de planejamento, ou seja onde  realmente vemos as etapas que precisam ser feitas para desenvolver o software.Se CRIA um cronograma, define se quais são as tarefas com base naqueles requisitos criados no requerimento. Monta-se o time de desenvolvimento, divide ele, modela a interface,a  Arquitetura, define a linguagem de desenvolvimento.

Temos um mapa do processo de desenvolvimento que vai ser utilizado na etapa seguinte, que é a parte de implementação. E nessa etapa é onde realmente acontece a mão na massa do time de desenvolvimento, dos programadores e arquitetos de acordo com a fase 1.Implementação fase de codar.

Verificação/teste para ver se o software obteve o objetivo definido nos requisitos, estressar o sistema, colocar o chapéu de usuário. 

Manutenção é o momento o qual o software vai para produção e o cliente testa para ele validar .

<img width="401" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/a1f6ec9f-a436-4463-8353-a4dc3b793277">


**Pair Programing**
<img width="611" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/e63e986f-85db-4d0b-ba0e-72a7eefa562f">

<img width="512" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/f5465fda-08e6-4997-a583-015a76bd8127">

sempre tem uma troca de papéis, o navegador se torna piloto, e o piloto se torna navegador, eles sempre discutem enquanto desenvolvem, sempre se comunicam.

é importante manter a etapa de code review

<img width="334" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/bb5bd94b-9bf8-4954-844c-43d9d0446ec3">

Solução otimizada, duas pessoas pensando no mesmo problema.

**Desk Check**

<img width="526" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/4f5fbafa-851c-480c-8423-2430ab753d73">

O desk check deve ser feito após a conclusão do desenvolvimento pelo o dev. O objetivo é conformar se os crtérios de aceite foram atendidos.

<img width="587" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/e5a11b04-12a2-45b3-a0bb-db6c1f2b279d">

O desk Check ocorre depois do desenvolvimento e antes do code review
<img width="626" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/4032cef0-c9aa-4794-a5ac-7e6e0052b79a">

é bem comum ter um check list para perguntar durante a reunião? se pergunta o que você já fez, cobriu todos os requisitos da História? foi testado manualmente?
foi verificado que aquela história impacta em algum abbiente, foi confirmado se a jornada do cliente foi completamente testada?

Estamos aqui para entregar solução e não tarefa, precisa completar a jornada, a História completa. Se foi testado todos os caminhos alternativos pelo o desenvolvedor e não só o caminho feliz.
Se a História precisa de uma correção.


**Shift Left Testing**

<img width="569" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/a0164ed7-c1db-408b-9045-240cce9450fb">

<img width="543" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/cc83f984-5035-452d-91c4-627f29c32cc4">

Conforme vimos acima no Ciclo de Desenvolvimento do Software + Devops

<img width="543" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/7c442d0c-585f-477e-aca6-4461f7f58a07">


E aí, trazendo essa imagem novamente, a gente vê que o teste ele está aqui nesse momento apenas, e já se passaram vários processos antes de chegar na etapa de teste.

E o que o Shift left test diz? Ele defende que a abordagem de teste precisa começar o quanto antes, seja na etapa de design codificação. Então quanto antes eu trazer ela a esquerda para iniciação da atividade de teste, por exemplo no "analisys and code"

No nome dessa  abordagem trás testing , mas não necessariamente estamos falando de executar os testes de fato, você pode estar aplicando mais qualidade utilizando alguns tipos de ferramentas, Por exemplo: o TDD, o BDD essas abordagens trabalham antes na etapa de "analysis and code" isso tudo nos ajuda a trazer mais qualidade para o produto final.

assim conseguimos prever diversos problemas.

<img width="613" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/bace0d6b-63d0-458b-8041-e1756205182d">

quanto mais ráído eu encontro um problema, mais rápido eu corijo.


**Quadrate de teste Ágil**

<img width="498" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/ac26ab57-bde6-40fe-9c76-f9ad6316e64d">

No quadrante Q1 é realizado mais pelos os desenvolvedores, sempre quando pensamos num teste de unidade ou  de componente devemos optar por automatizar, veja a indicação da nuvem. São testes que rodam de forma rápida, te dão um feedback rápido. por isso precisa ser automatizado.

o segundo quadrante Q2 ele é mais focado no funcional. Servem muito de apoio para o time de desenvolvimento mais num nível funcional, ou seja verificando software a um nível de critério de aceite, uma visão mais voltada para o cliente, está avaliando se o que foi desenvolvido está alinhado com o negócio. Podem ser executado de forma manual ou automatizada, vai depender da necessidade

indo para o terceiro quadrante Q3, tem mais uma visão de explorar o sistema, descobrir novos cenários, esses testes são bem manuais, com a visão do usuário, pode ser um QA , um BI , um cliente.

Indo para o 4 quadrante Q4, está focado nas tecnologias que vem para apoiar o nosso negócio, são ferramentas, o foco é garantir o desempenho, segurança, que não esteja focado apenas no funcional. 

**TDD-Test Driven Development**

Desenvolvimento Guiado por teste, primeiro testa depois desenvolve.

<img width="553" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/0bdfdcd1-102d-48b9-a799-ebeff1ddb57c">

Primeiro cria os testes unitários, e ser guiado não apenas pela expertise do dev e sim pelo o teste.

Exemplo, o desenvolvedor precisa implementar uma calculadora:

<img width="554" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/26c3b49b-3235-4c54-bb75-e5b61caf8cb5">

<img width="596" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/647a9de1-dd00-4f29-a9f6-743ab4c9d322">

1 falha por que o código não está criado, só após o item dois ser criado que é possivel compilar.

<img width="603" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/82b312b0-a457-4a65-b02b-f36aede7187c">

**BDD - Behavior Driven Development**

<img width="605" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/96294636-8cd1-4b4f-885e-3c91a168fbea">

<img width="578" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/b58837e3-3d28-4c8c-bc4b-f36963f5fb3a">

<img width="623" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/e13ae74f-aeb1-4893-af81-06987e4d80ef">

<img width="491" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/e592c528-a676-44ce-b05a-095489e788fd">

BDD não é dado, quando então(linguagem GERKIN) ,não é a descrição da funcionalidade, não é a automação, na verdade é a cerimônia entre os envolvidos para 
entender como a aplicação deve se comportar, e o output é essa documentação;

Ganhos para se incorporar essa cerimônia dentro do time:

<img width="595" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/b8b63351-c0fc-4bb9-ac5a-6db3e2f21433">


Quando eu digo que estou desenvolvendo guiado por comportamento, quer dizer que o meu numero 1 é o resultado, é o que eu espero que a minha aplicação faça. 
Eu não estou desenvolvendo código baseado no que eu sei, mas numa documentação de comportamento que é o BDD.

Quando eu estou numa cerimonia de BDD eu tiro todas as dúvidas; Tenho uma documentação mais especifica além da jornada

O cucumber é uma ferramenta que significa pepino e ele é um framework que trabalha com a linguagem GERKIN (DADO, QUANDO , ENTÃO) ele nos possibilita automatizar esses cenários com essa  linguagem.


**ATDD - Acceptance Test Driven Development**

<img width="572" alt="image" src="https://github.com/aevilesaguiar/qualidade-de-software/assets/52088444/83d4b45f-d339-4a6a-88d3-4568cc57313d">

ATDD valida o comportamento do sistema, olhando bem para a parte funcional. O objetivo aqui é criar especificações executáveis. Essas epecificações vem surgindo através de discussões entre o time de desenvolvimento, QA, Stakeholders , time de negócios.

Ela é dividida em 4 partes:

- 1. Debater: o time de desenvolvimento se junta com as partes interessadas do negócio e eles entram num discussão, o time de desenvolvimento tem que desenvolver a compreensão do sistema pelo o ponto de vista do usuário. Com base nesse entendimento será criado os testes de aceitação,  durante essa fase de discussão a equipe tem a oportunidade de esclarecer os mals entendidos, é uma reunião para sair sem dúvidas, todas as duvidas devem ser clarificadas, para que nao coloque um bug no sistema. Essa fase serve para que todos estejam na mesma página, com relação a funcionalidade que será entregue. E  o resultado é ter esses testes de aceitação em forma de frases, para que seja compreendido por todos da organização.
  2. Refinar: nessa etapa convertemos os nossos testes que são produzidos na etapa anterior, colocando eles num framework, fazendo com que eles sejam executáveis, nesse momento garantimos que os testes não sejam só uma especificação, uma frase, e sim algo executável dentro do projeto. Esses testes vão falhar, por que até então estamos olhando só para os testes. As funcionalidades não existem esse é o momento que estamos utilizando o que agente debateu na fase anterior e transformando aquilo em um teste executável.
  3. Desenvolver:  durante essa fase o time de desenvolvimento vai executar os testes, verificar o que está causando erro  e em seguida escrever o código, o pensamento é similar ao TDD, mas o foco é o comportamento do sistema, no ponto de vista do usuário, aceitação;
  4. Revisão: ou demonstração, envolve as pessoas interessadas, aqui identificamos os testes ue foram realizados, as vulnerabilidade que foram identificadas, validar se o objetivo inicial da fase de debate conseguimos concluir.
